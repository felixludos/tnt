<!DOCTYPE html>
<html>
  <head>
    <title>test</title>
    <link rel="shortcut icon" href="#" />
    <link rel="stylesheet" type="text/css" href="/css/main.css" />
    <link rel="stylesheet" type="text/css" href="/css/layout.css" />
    <link rel="stylesheet" type="text/css" href="/css/msStyles.css" />
    <link rel="stylesheet" type="text/css" href="/css/autocomp.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/3.12.2/js-yaml.js"></script>
    <script src="https://www.w3schools.com/lib/w3.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <script src="/js/autocomplete.js"></script>
    <script src="/js/helpers.js"></script>
    <script src="/js/panzoom.js"></script>
    <script src="/js/MS.js"></script>
    <script src="/js/NPage.js"></script>
    <script src="/js/NGrouping.js"></script>
    <script src="/js/NObj.js"></script>
    <!-- <script src="/js/BoardFactory.js"></script>
    <script src="/js/CardFactory.js"></script> -->

    <script src="/js/scenario0.js"></script>
    <script src="/js/scenario1.js"></script>
    <script src="/js/scenario2.js"></script>
  </head>
  <body>
    <!-- #region HTML -->
    <div id="mainDiv" class="grid_game">
      <div id="menu_area" class="grid_div" style="text-align:left;">
        <div style="float:left;margin-left:10px">
          <button id="bLoadScenario" onclick="onClickLoadScenario()">load scenario</button>
          <button id="bStartScenario" onclick="onClickStartScenario()">start scenario</button>
          <button id="bSkipAction" onclick="skipAction()">skip action</button>
        </div>
        <div style="float:right;margin-right:10px">
          view:
          <button id="bViewGame" onclick="page.gameView()">game</button>
          <button id="bViewNoReserve" onclick="page.gameView(false)">no reserve</button>
          <button id="bViewEdit" onclick="page.editView()">edit</button>
          <button id="bViewTest" onclick="page.testView()">test</button>
        </div>
      </div>
      <div id="status_area" class="grid_div" onclick="page.testView()">status</div>
      <div id="test_area" class="grid_div">
        <div class="flexdiv">
          <div class="autocomplete">
            <input id="myInput" type="text" name="myCountry" style="font-size:30px;" placeholder="command" />
          </div>
          <div class="autocomplete">
            <input id="inparam" type="text" name="inparam" style="font-size:30px;" placeholder="param" />
          </div>
          <button style="margin:10px" id="bSendMessage" onclick="onClickSendMessage()">send message</button>
          <button style="margin:10px" id="bClear" onclick="onClickClearInputs()">clear inputs</button>
        </div>
      </div>
      <div id="reserve_area" class="grid_div">
        <svg id="selSvg" width="60" height="760"><g id="reserveG"></g></svg>
      </div>
      <div id="map_area" class="grid_div" style="background-color:rgba(86, 182, 222);">
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="mapG" viewBox="0 0 3400 2200">
            <image id="imgMap" width="3400" height="2200" href="/assets/TTmap.jpg" />
          </g>
        </svg>
      </div>
      <div id="log_area" class="grid_div" style="overflow-y:scroll">
        Messages
        <div id="tempDisplay" class="hidden" style="width:100%;height:100%">
          <svg width="100%" height="100%" style="box-sizing:border-box;">
            <g id="tempG"></g>
          </svg>
        </div>
      </div>
      <div id="prop_area" class="grid_div hidden">properties</div>
      <div id="command_area" class="grid_div">
        Commands
        <button id="bNextPlayer" class="hidden" onclick="onClickNextPlayer()">next player</button>
      </div>
      <div id="chat_area" class="grid_div hidden">chat</div>
      <div id="hand_area" class="grid_div" style="height:200px">
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="handG"></g>
        </svg>
      </div>
      <div id="openCard_area" class="grid_div" style="height:200px">
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="openCardG"></g>
        </svg>
      </div>
      <div id="actionDeck_area" class="grid_div hidden" style="height:200px">
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="actionDeckG"></g>
        </svg>
      </div>
      <div id="investmentDeck_area" class="grid_div hidden" style="height:200px">
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="investmentDeckG"></g>
        </svg>
      </div>
    </div>
    <!-- #endregion HTML -->

    <!-- #region globals -->
    <script>
      var backendServerUrl = "http://localhost:5000/"; //local server
      var msgCounter = 0;
      var serverData; // last message from server as JSON object
      var postData = scenario0;

      var G = {hasVisuals: false, oServer: {}, oFront: {}, groupings: {}}; //complete game state
      //oFront: objects made by front
      // permanent for duration of session:
      //   unit_types, unit_nationalities, influence_spots, chips, commands, decks
      // destroy on reload/and re-create lazily:
      //   unitSum, peace counter, influences
      //oServer: objects made by server, new when load/refresh, incrementally renewed im normalfall
      //   units: change multiple things including id
      //   influences: -"- change id as well
      //   tiles: dont ever change at all
      //   cards: only change owner/parentG but not id
      var player = "West";
      var year = "1935";
      var phase = "setup";

      var messages = [
        "changeToWest",
        "changeToUSSR",
        "changeToAxis",
        "initWest",
        "initUSSR",
        "initAxis",
        "load01",
        "load02",
        "load03",
        "loadTest",
        "myload",
        "noWest",
        "postTest", // all post messages should start with 'post'
        "prodAgent",
        "save01",
        "save02",
        "save03"
      ];
      var filenames = [
        "gov_complete.json",
        "init_complete.json",
        "prod_complete.json",
        "scAgent.json",
        "setup_complete.json",
        "test.json",
        "_gs01.json"
      ];
      var page;

      var tilePositions, nationPositions, trackPositions;
      var tileNames, nationalityNames, unitTypeNames, nationNames, unitCountInfo;
      const SZ = {
        //various sizes used
        region: 180,
        pAxis: {x: 0, y: 20}, // this is where on the region placement of cadre is started
        pWest: {x: -50, y: -30},
        pUSSR: {x: +50, y: -30},
        cadrePrototype: 60,
        sumCadre: 60,
        cadreDetail: 44,
        cardWidth: 100,
        cardHeight: 150,
        gap: 10,
        chip: 40,
        influence: 100
      };
      const troopColors = {
        Germany: [174, 174, 176],
        Britain: [86, 182, 222],
        France: [121, 200, 205],
        USSR: [233, 138, 134],
        USA: [145, 186, 130],
        Italy: [174, 172, 131],
        Neutral: [255, 255, 102],
        Axis: [174, 174, 176],
        West: [86, 182, 222]
      };
    </script>
    <!-- #endregion globals -->

    <!-- #region handlers using globals  -->
    <script>
      function onClickClearInputs() {
        document.getElementById("myInput").value = "";
        document.getElementById("inparam").value = "";
      }
      function onClickLoadScenario() {
        loadScenario();
      }
      function onClickSendMessage() {
        let inp = document.getElementById("myInput");
        let msg = inp.value.toString();
        inp.value = "";
        let inparam = document.getElementById("inparam");
        let msgParam = inparam.value.toString();
        inparam.value = "";
        sendOrPost(msg, msgParam, postData);
      }
      function onClickStartScenario() {
        page.editView();
        newScenario(scenario0);

        //before that, have to make scenario!!!
        //which means: from scenario0 (global var) make modifications
        //then call post('postTest',data,callback)
        //this last step will save data to server: saves/test.json
        //TODO: to be parameterized later!
        //1. select which phase to start from
        //2. the goal of a scenario is to determine which game objects
        //should exist
        //each player should get specific:
        // - units
        // - cards
        // - influence
        // during scenario setup, should have
        // - selectables open: all 6 nationalities, all 7 unit types
        // - cards open: all action cards, all investmend cards
        // (alternatively, could just have list of cards by title)
        // - all tiles should be selectable for placement of units
        // - all nation spots (influence) should be selectable
        // example:
        // select player for which to choose objects
        // objects on the board or in hand can be selected and deleted!
        // p0: only offer this first possibility!
        //
        // first function to set up objects from object table
      }
    </script>
    <!-- #endregion handlers using globals  -->

    <!-- #region function  -->
    <script>
      function addNationPositions(nationsDict) {
        nationPositions = nationsDict;
        let res = [];
        for (const nat in nationsDict) {
          let pos = getNationPos(nat);
          //let id = nat.replace(/\s/g,'_');
          // if (nat.includes(' ')||nat.includes('_')){
          //   //console.log('nation id',nat)
          //   //console.log('nationNames',nationNames);
          // }
          let ms = new NObj(nat, "mapG", {obj_type: "nationUI"})
            .circle({className: "overlay nation", sz: SZ.influence})
            .setPos(pos.x, pos.y)
            .draw();
          ms.tag("type", "nation");
          res.push(ms);
        }
        return res;
      }
      function calculateTrackPositions() {
        trackPositions = {};
        let arr = [];
        let x = 580;
        let y = 2120;
        for (let i = 0; i < 25; i++) {
          arr.push({x: x, y: y});
          x += 66;
        }
        trackPositions.Axis = arr;

        arr = [];
        x = 1310;
        y = 76;
        for (let i = 0; i < 20; i++) {
          arr.push({x: x, y: y});
          x -= 66;
        }
        for (let i = 20; i < 25; i++) {
          arr.push({x: x, y: y});
          y += 66;
        }
        trackPositions.West = arr;

        arr = [];
        x = 2210;
        y = 76;
        for (let i = 0; i < 18; i++) {
          arr.push({x: x, y: y});
          x += 66;
        }
        for (let i = 18; i < 25; i++) {
          arr.push({x: x, y: y});
          y += 66;
        }
        trackPositions.USSR = arr;
      }
      function calcUnitStartPos(tile, faction) {
        let pFaction = SZ["p" + faction];
        let pTile = getTilePos(tile);
        return {x: pTile.x + pFaction.x, y: pTile.y + pFaction.y};
      }
      function canCreateUnits() {
        let ph = phase.toLowerCase();
        return startsWith(ph, "set") || startWith(ph, "prod");
      }
      function chainSend(data, msgChain, callback) {
        try {
          serverData = JSON.parse(data);
          //console.log(serverData);
        } catch {
          //console.log(data);
        }
        if (msgChain.length > 0) {
          send(msgChain[0], d => chainSend(d, msgChain.slice(1), callback));
        } else {
          callback(data);
        }
      }
      function clearG() {
        if (!G.hasVisuals) {
          return;
        }
        for (const id in G.oServer) {
          const o = G.oServer[id];
          o.visual.removeFromUI();
        }
        G.oServer = {};
        let ids = [];
        //TODO: what else do I have to remove from oFront?!?
        for (const id in G.oFront) {
          //remove units,
          const o = G.oFront[id];
          if (isUnit(o)) {
            o.visual.removeFromUI();
            ids.push(id);
          }
        }
        for (const id of ids) {
          delete G.oFront[id];
        }
        for (const id in G.groupings) {
          G.groupings[id].clear();
        }
        G.hasVisuals = false;
      }
      function createChip(id, {text = "", filename = "", prefix = "", faction = "", color = "beige"} = {}) {
        //id is also the filename
        let sz = SZ.chip;
        let pts = trackPositions[faction];
        let pos = pts[0];
        let ms = new NObj(id, "mapG", {obj_type: "chip"})
          .roundedRect({w: sz, h: sz, fill: color})
          .text({txt: text, fill: "white", weight: "bold"})
          .setPos(pos.x + sz / 2, pos.y + sz / 2)
          .draw();
        return ms;
      }
      function createDecks() {
        let wDeckArea = 251;
        let hDeckArea = 354;
        let pos = {x: 166, y: 998};
        let centerActionDeck = {x: 166, y: 998}; // center of action deck
        let centerInvestmentDeck = {x: 3233, y: 966}; // center of investment deck
        let rounding = 6;
        let actionDeckColor = "orange";
        let idAction = "action_card";
        let idInvestment = "investment_card";
        let actionDeck = new NObj(idAction, "mapG", {objType: "deckUI"})
          .roundedRect({w: 251, h: 354, fill: actionDeckColor, rounding: 6})
          .textMultiline({txt: ["Action", "Deck"], fz: 28, fill: "white"})
          .roundedRect({className: "cardDeck overlay", w: 251, h: 354, rounding: 6})
          .setPos(centerActionDeck.x, centerActionDeck.y)
          .draw();
        let investmentDeck = new NObj(idInvestment, "mapG", {objType: "deckUI"})
          .roundedRect({w: 253, h: 356, fill: "sienna", rounding: 6})
          .textMultiline({txt: ["Investment", "Deck"], fz: 28, fill: "white"})
          .roundedRect({className: "cardDeck overlay", w: 253, h: 356, fill: "transparent", rounding: 6})
          .setPos(centerInvestmentDeck.x, centerInvestmentDeck.y)
          .draw();
        return {action_card: actionDeck, investment_card: investmentDeck};
      }
      function createVisual(id, o) {
        //console.log(id, o);

        if (isTile(o)) {
          let pos = getTilePos(id);
          //console.log(pos, id);
          //console.log("createRegion id=", id, "pos=", pos, "ttext=", ttext, this.SZ.region);
          let msRegion = new NObj(id, "mapG", o)
            .circle({className: "overlay region", sz: SZ.region})
            .setPos(pos.x, pos.y)
            .draw();
          o.visual = msRegion;
          return msRegion;
        } else if (isUnit(o)) {
          o.owner = getUnitOwner(o.nationality);
          let tile = o.tile;
          let sz = SZ.cadreDetail;
          let groupId = getUnitGroupId(o); // is at same time id of hiddenVisual
          let startPos = calcUnitStartPos(tile, o.owner); // is at same time pos of hiddenVisual

          // get group unit belongs to
          if (!(groupId in G.groupings)) {
            let snailPos = calcSnailPositions(0, 0, sz, 25);
            let group = new NGrouping(groupId, "mapG", "snail", startPos, {snailPos: snailPos});
            G.groupings[groupId] = group;
          }
          let grouping = G.groupings[groupId];

          //create unit and add it to group
          let imagePath = "/assets/images/" + o.type + ".svg";
          let color = troopColors[o.nationality];
          let darker = darkerColor(color[0], color[1], color[2]);
          //console.log('colors:',color,darker);
          let sz90 = sz * 0.96;
          let sz80 = sz * 0.86;
          let szImage = sz / 1.5;
          let y = szImage / 6;
          let ms = new NObj(id, "mapG", o)
            .roundedRect({w: sz, h: sz, fill: color, rounding: sz * 0.1})
            .roundedRect({w: sz80, h: sz80, fill: darker, rounding: sz * 0.1})
            .image({path: imagePath, y: y, w: szImage, h: szImage})
            .roundedRect({className: "overlay", w: sz, h: sz, fill: darker, rounding: sz * 0.1});
          if ("cv" in o) {
            updateCv(ms, o.cv);
          }
          grouping.add(ms);
          o.group = grouping;
          o.visual = ms;

          // get or create hiddenVisual
          if (!(groupId in G.oFront)) {
            //create a hiddenVisual for this tile and faction
            // if (o.owner == 'Axis'){
            //   //console.log('size',sz)
            // }
            let sz = SZ.sumCadre;
            let sz80 = sz * 0.86;
            let msHidden = new NObj(groupId, "mapG", o)
              .roundedRect({w: sz, h: sz, fill: color, rounding: sz * 0.1})
              .roundedRect({w: sz80, h: sz80, fill: darker, rounding: sz * 0.1})
              .text({className: "content", txt: 1, fz: sz / 2, fill: "white"})
              .roundedRect({className: "overlay", w: sz, h: sz, fill: darker, rounding: sz * 0.1});
            msHidden.tag("content", 1);
            msHidden.setPos(startPos.x, startPos.y).draw();
            let oHidden = {faction: o.owner, tile: tile, obj_type: "unit_hidden", visual: msHidden};

            G.oFront[groupId] = oHidden;
          } else {
            updateUnitCounter(o, G.oFront[groupId].visual, 1);
          }
          let msHidden = G.oFront[groupId].visual;

          //attach hiddenVisual to o
          o.hiddenVisual = msHidden;

          //o has been extended by: owner,group,visual,hiddenVisual

          //NObj needs a way to modify content
          //NGroup needs a way to show or hide entire group

          //visibility of newly created unit: if visible to player,
          if (o.visible.set.includes(player)) {
            ms.show();
            msHidden.hide();
          } else {
            ms.hide();
            msHidden.show();
          }

          return ms;
        } else if (isCard(o)) {
          let parentName = null;
          //console.log("card is", o);
          if ("owner" in o && o.owner == player) {
            parentName = "handG";
          } else if (!("visible" in o)) {
            //console.log('no visible property:',o);
          } else if (!("set" in o.visible)) {
            //console.log('no set property:',o);
          } else if (o.visible.set.length == 3) {
            parentName = "openCardG";
          } else if (o.visible.set.includes(player)) {
            //this card is temporarily shown to that player but does not belong to him!
            // show it in >>tempDisplay
            parentName = "tempG";
          } else if (empty(o.visible.set)) {
            if (isEditView()) {
              // deck card, invisible or if in edit mode visible in one of the deckGs
              if (isActionCard(o)) {
                parentName = "actionDeckG";
              } else {
                parentName = "investmentDeckG";
              }
            } else {
              // this card will not be added anywhere yet!
            }
          }
          if (parentName) {
            if (!(parentName in G.groupings)) {
              let w = SZ.cardWidth;
              let h = SZ.cardHeight;
              let gap = SZ.gap;
              let startPos = {x: gap + w / 2, y: gap + h / 2};
              let divName = stringBefore(parentName, "G") + "_area";
              //console.log("divname", divName);
              let group = new NGrouping(parentName, parentName, "byRow", startPos, {
                w: w,
                h: h,
                gap: gap,
                div: document.getElementById(divName)
              });
              G.groupings[parentName] = group;
            }
            let grouping = G.groupings[parentName];
            ms = new NObj(id, parentName, o);
            setCardContent(ms, o);
            grouping.add(ms);
            o.visual = ms;
            o.group = grouping;
          }
          return ms;
        } else if (isInfluence(o)) {
          ms = new NObj(id, "mapG", o);
          drawInfluence(ms, o.nation, o.faction, o.value);
          let pos = getNationPos(o.nation);
          ms.setPos(pos.x, pos.y).draw();
          o.visual = ms;
          return ms;
        }
      }
      function createNPage() {
        return new NPage(
          document.getElementById("mainDiv"),
          document.getElementById("actionDeck_area"),
          document.getElementById("chat_area"),
          document.getElementById("command_area"),
          document.getElementById("hand_area"),
          document.getElementById("investmentDeck_area"),
          document.getElementById("log_area"),
          document.getElementById("menu_area"),
          document.getElementById("openCard_area"),
          document.getElementById("prop_area"),
          document.getElementById("reserve_area"),
          document.getElementById("status_area"),
          document.getElementById("test_area")
        );
      }
      function createSelectable(id) {
        //add a simple selectable object to reserve area reserveG
        let ms = undefined;
        //console.log('createSelectableOrCommand',nationalityNames,id)
        if (nationalityNames.includes(id) || unitTypeNames.includes(id)) {
          let d = document.getElementById("reserve_area");
          let g = document.getElementById("reserveG");
          let sz = SZ.cadreDetail;
          let type = nationalityNames.includes(id) ? "nationality_type" : "unit_type";
          let color = type == "nationality_type" ? troopColors[id] : "black";

          //need reserve_group
          let groupId = "reserve";
          if (!(groupId in G.groupings)) {
            let gap = 10;
            let startPos = {x: gap + sz / 2, y: gap + sz / 2};
            let group = new NGrouping(groupId, "reserveG", "byCol", startPos, {
              div: document.getElementById("reserve_area"),
              objType,
              w: sz,
              h: sz,
              gap: gap
            });
            G.groupings[groupId] = group;
          }
          let grouping = G.groupings[groupId];

          //create ms
          let o = {obj_type: type, group: grouping};
          ms = new NObj(id, "reserveG", o).roundedRect({w: sz, h: sz, fill: color, rounding: sz * 0.1});
          if (type == "nationality_type") {
            ms.text({txt: id, fz: 12});
          } else {
            ms.image({w: sz, h: sz, path: "/assets/images/" + id + ".svg", rounding: sz * 0.1});
          }
          ms.roundedRect({className: "overlay", w: sz, h: sz, rounding: sz * 0.1});
          ms.tag("type", type);
          //console.log(id,ms);

          grouping.add(ms);
          o.group = grouping;
          ensureSelectables();
          G.oSelectables[id] = o;
          return ms;
        }
      }
      function drawInfluence(ms, nation, faction, level) {
        let imagePath = "/assets/images/" + faction + ".svg";
        let color = troopColors[faction];
        //console.log('COLOR:',color)
        let darker = darkerColor(color[0], color[1], color[2]);
        let szBase = SZ.influence / 1.5;
        let szRest = SZ.influence - szBase;
        let sz = szBase + (szBase * (level - 1)) / 2; //influence grows with level!
        let sz90 = sz * 0.96;
        let sz80 = sz * 0.86;
        let szImage = 30; //sz / 1.5;
        let y = szImage / 6;
        let text = level;
        let fontColor = level == 1 ? "black" : level == 2 ? "red" : darker;
        ms.circle({fill: "yellow", alpha: 1, sz: sz})
          .circle({fill: darker, sz: szImage + 6})
          .circle({fill: color, sz: szImage + 4})
          .image({path: imagePath, w: szImage, h: szImage})
          .text({txt: text, fill: fontColor, fz: szImage - 5, weight: "bold"})
          .circle({className: "overlay", sz: sz});
        //ms.tag("ttext", ttext); //for tooltip, not yet used
        ms.tag("nation", nation);
        ms.tag("faction", faction);
        ms.tag("level", level);
        ms.tag("type", "influence");
        return ms;
      }
      function ensureCommands() {
        if (!("commands" in G)) {
          G.oCommands = {};
        }
      }
      function ensureSelectables() {
        if (!("selectables" in G)) {
          G.oSelectables = {};
        }
      }
      function getMapPos(o) {
        if (o.obj_type == "tile") return tilePositions[o.name];
        else return nationPositions[o.nation];
      }
      function getNationPos(nation) {
        return nationPositions[nation];
      }
      function getTilePos(tile) {
        return tilePositions[tile];
      }
      function getUnitGroupId(o) {
        return o.tile + "_" + o.owner;
      }
      function getUnitOwner(nationality) {
        if (nationality == "Germany" || nationality == "Italy") {
          return "Axis";
        } else if (nationality == "USSR") {
          return "USSR";
        } else if (nationality == "Britain" || nationality == "France") {
          return "West";
        } else {
          return "Neutral";
        }
      }
      function isActionCard(o) {
        return o.obj_type == "action_card";
      }
      function isCard(o) {
        return endsWith(o.obj_type, "card");
      }
      function isEditView() {
        //console.log("isEditView!!!!!");
        let res = document.getElementById("mainDiv").classList.contains("grid_edit");
        //console.log(document.getElementById("mainDiv").classList, res);
        return res;
      }
      function isInfluence(o) {
        return o.obj_type == "influence";
      }
      function isTile(o) {
        return o.obj_type == "tile";
      }
      function isUnit(o) {
        return o.obj_type == "unit" || o.obj_type == "unit_hidden";
      }
      function loadAssets(callback) {
        //console.log("loading...");
        calculateTrackPositions();
        loadYML("/assets/config/map_pos.yml", data => {
          tilePositions = {};
          for (idTile in data) {
            let id = replaceAll(idTile, " ", "_");
            tilePositions[id] = data[idTile];
          }
          tileNames = Object.keys(tilePositions);
          loadYML("/assets/config/nations.yml", data => {
            nationPositions = {};
            for (idNation in data) {
              let id = replaceAll(idNation, " ", "_");
              nationPositions[id] = data[idNation];
            }
            nationNames = Object.keys(nationPositions);
            // nationPositions = data;
            // nationNames = Object.keys(data);
            loadYML("/assets/config/unit_count.yml", data => {
              unitCountInfo = data;
              nationalityNames = Object.keys(data);
              unitTypeNames = Object.keys(data["Germany"]);

              //create decks
              let decks = createDecks();
              let o = {obj_type: 'deck', visual: decks.action_card};
              G.oFront.action_card = o;
              o = {obj_type: 'deck', visual: decks.investment_card};
              G.oFront.investment_card = o;

              //load influence spots
              let msNationList = addNationPositions(nationPositions);
              msNationList.map(x => (G.oFront[x.id] = {obj_type: 'nation', visual: x}));

              //console.log("...finished loading!");
              callback();
            });
          });
        });
      }
      function loadScenario() {
        //before that, have to make scenario!!!
        //which means: from scenario0 (global var) make modifications
        //then call post('postTest',data,callback)
        //this last step will save data to server: saves/test.json
        //TODO: to be parameterized later!
        let msgChain1 = ["myload/test.json", "noWest"];
        chainSend("start", msgChain1, data => {
          //the last call was to noWest,
          //it either has a waiting_for or an actions
          //if it is waiting_for, look at waiting_for.set[0] as next players
          // otherwise West is next player
          let jData = JSON.parse(data);
          nextPlayer = "West";
          if ("waiting_for" in jData) {
            nextPlayer = jData.waiting_for.set[0];
          }
          // have next player!
          send("status/" + nextPlayer, receive);
        });
      }
      function newScenario(scenario) {
        clearG();
        console.log("start:", G);

        G.oServer = scenario.gamestate.objects.table;

        //first create all the tiles!
        for (const id in G.oServer) {
          let o = G.oServer[id];
          if (isTile(o)) {
            let ms = createVisual(id, o);
          }
        }
        for (const id in G.oServer) {
          let o = G.oServer[id];
          if (!isTile(o)) {
            let ms = createVisual(id, o);
          }
        }

        //update tracks
        for (const faction in scenario.gamestate.players) {
          const tracks = scenario.gamestate.players[faction].tracks;
          setPopulation(faction, tracks.POP);
          setResource(faction, tracks.RES);
          setIndustry(faction, tracks.IND);
        }
      }
      function post(url, data, callback = null) {
        url = backendServerUrl + url;
        msgCounter += 1;
        //console.log(msgCounter, "POST request sent: ", url, data);
        $.ajax({
          url: url,
          type: "POST",
          data: JSON.stringify(data),
          processData: false,
          contentType: "application/json; charset=UTF-8",
          success: function(response) {
            //console.log(response);
            if (callback) {
              callback(response);
            }
          },
          error: function(error) {
            //console.log(error);
          }
        });
      }
      function receive(serverText) {
        try {
          serverData = JSON.parse(serverText);
          //console.log(serverData);
        } catch {
          //console.log(serverText);
        }
      }
      function sendOrPost(msg, msgParam, data) {
        if (!empty(msgParam)) msg += "/" + msgParam;
        //console.log("sending", msg);
        if (startsWith(msg, "post")) {
          post(msg, data);
        } else {
          send(msg);
        }
      }
      function send(url, callback = null) {
        url = backendServerUrl + url;
        msgCounter += 1;
        //console.log(msgCounter, "request sent: ", url);
        w3.http(url, function() {
          if (this.readyState == 4 && this.status == 200) {
            if (callback) {
              callback(this.responseText);
            } else {
              receive(this.responseText);
            }
          }
        });
      }
      function setCardContent(ms, o) {
        let txt = [];
        let title = "";
        if ("top" in o) {
          if (o.obj_type == "action_card") {
            txt = [o.top, " ", o.season, o.priority + o.value, " ", o.bottom];
          } else {
            txt = [o.top, " ", " ", o.value ? o.value.toString() : " ", " ", " ", o.bottom];
          }
          title = o.top;
        } else if ("wildcard" in o) {
          txt = [o.wildcard, " ", o.season, o.priority + o.value, " ", " "];
          title = o.wildcard;
        } else if ("intelligence" in o) {
          txt = [o.intelligence, " ", " ", o.value ? o.value.toString() : " ", " ", " ", " "];
          title = o.intelligence;
        } else if ("science" in o) {
          txt = [o.value + "   (" + o.year.toString() + ")"];
          o.science.map(x => txt.push(x));
          title = o.year;
        }
        if (txt.length > 0) {
          //console.log(txt)
          txt = txt.map(x => x.replace(/_/g, " "));
        }
        let cardWidth = SZ.cardWidth;
        let cardHeight = SZ.cardHeight;
        //console.log(cardWidth, cardHeight);

        let testText = ms.id;
        if ("owner" in o) {
          testText += " " + o.owner;
        }

        ms.roundedRect({w: cardWidth, h: cardHeight, fill: "white"})
          .text({txt: testText, fill: "red", y: cardHeight / 2, fz: cardWidth / 7})
          .textMultiline({txt: txt, maxWidth: cardWidth, fz: cardWidth / 7}) // / 6})
          .roundedRect({className: "overlay", w: cardWidth, h: cardHeight});

        ms.tag("content", txt);
        ms.tag("type", o.obj_type);
        ms.tag("title", title);
        ms.tag("json", JSON.stringify(o));
        return ms;
      }
      function setPopulation(faction, n) {
        setChip("pop", "P", faction, n, "sienna");
      }
      function setIndustry(faction, n) {
        setChip("ind", "I", faction, n, "red");
      }
      function setResource(faction, n) {
        setChip("res", "R", faction, n, "green");
      }
      function setChip(prefix, text, faction, n, color) {
        let pts = trackPositions[faction];
        let pos = pts[n - 1];
        let id = prefix + faction;
        if (!(id in G.oFront)) {
          let o = createChip(id, {text: text, prefix: prefix, faction: faction, color: color});
          G.oFront[id] = {obj_type: 'chip', visual: o};
        }
        let ms = G.oFront[id].visual;
        ms.setPos(pos.x, pos.y);
      }
      function updateUnitCounter(o, ms, inc) {
        //console.log('updateUnitCounter')
        let n = ms.getTag("count");
        n += inc;
        let color = troopColors[o.nationality];
        let darker = darkerColor(color[0], color[1], color[2]);
        let sz = SZ.sumCadre;
        ms.removeFromChildIndex(3);
        ms.text({txt: n, fz: sz / 2, fill: "white"}).roundedRect({
          className: "overlay",
          w: sz,
          h: sz,
          fill: darker,
          rounding: sz * 0.1
        });
        ms.tag("count", n);
      }
      function updateCv(msUnit, cv) {
        //console.log(cv,typeof(cv))
        //plaziere 1 circle foreach  #
        //muss alte punkte wegnehmen!!! falls welche hat!
        msUnit.removeFromChildIndex(5);
        //msUnit.circle({sz:20,fill:'white'});
        let sz = SZ.cadreDetail;
        let dx = sz / (cv + 1);
        let xStart = -sz / 2;
        let y = -sz / 3.2;
        let diam = Math.min(dx / 1.5, sz / 5);
        //console.log(dx,y)
        let x = dx + xStart;
        for (let i = 0; i < cv; i++) {
          msUnit.circle({sz: diam, x: x, y: y, fill: "white"});
          x += dx;
        }

        msUnit.tag("cv", cv);
      }
    </script>
    <!-- #endregion safe -->

    <!-- #region code execution  -->
    <script>
      $(document).ready(function() {
        //console.log(scenario0); //geht! obwohl in head geladen!
        document.getElementById("myInput").placeholder = "command " + uniqueFirstLetters(messages).toString();
        document.getElementById("inparam").placeholder = "file " + uniqueFirstLetters(filenames).toString();
        autocomplete(document.getElementById("myInput"), messages);
        autocomplete(document.getElementById("inparam"), filenames);
        page = createNPage();
        page.editView();

        let map = document.getElementById("mapG");
        map.setAttribute("transform", `translate(0,0) scale(${MIN_SCALE})`);
        //board.setAttribute("transform", `translate(-400,-400) scale(${1})`);
        map.addEventListener("wheel", ev => {
          onwheel(ev, map);
        });
        map.addEventListener("pointerdown", ev => {
          onmousedown(ev);
        });
        addEventListener("mouseup", ev => {
          onmouseup(ev, map);
        });
        addEventListener("mousemove", ev => {
          onmousemove(ev, map);
        });
        addEventListener("dblclick", ev => reset(ev, map));

        loadAssets(() => startExecution());
      });

      function startExecution() {
        onClickStartScenario();
      }
    </script>
    <!-- #endregion  code execution -->
  </body>
</html>
